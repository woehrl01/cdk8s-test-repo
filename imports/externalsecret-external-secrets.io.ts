// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecret
 */
export class ExternalSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExternalSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1alpha1',
    kind: 'ExternalSecret',
  }

  /**
   * Renders a Kubernetes manifest for "ExternalSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExternalSecretProps = {}): any {
    return {
      ...ExternalSecret.GVK,
      ...toJson_ExternalSecretProps(props),
    };
  }

  /**
   * Defines a "ExternalSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExternalSecretProps = {}) {
    super(scope, id, {
      ...ExternalSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExternalSecret.GVK,
      ...toJson_ExternalSecretProps(resolved),
    };
  }
}

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecret
 */
export interface ExternalSecretProps {
  /**
   * @schema ExternalSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExternalSecretSpec defines the desired state of ExternalSecret.
   *
   * @schema ExternalSecret#spec
   */
  readonly spec?: ExternalSecretSpec;

}

/**
 * Converts an object of type 'ExternalSecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretProps(obj: ExternalSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExternalSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretSpec defines the desired state of ExternalSecret.
 *
 * @schema ExternalSecretSpec
 */
export interface ExternalSecretSpec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ExternalSecretSpec#data
   */
  readonly data?: ExternalSecretSpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ExternalSecretSpec#dataFrom
   */
  readonly dataFrom?: ExternalSecretSpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ExternalSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretSpec#secretStoreRef
   */
  readonly secretStoreRef: ExternalSecretSpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
   *
   * @schema ExternalSecretSpec#target
   */
  readonly target: ExternalSecretSpecTarget;

}

/**
 * Converts an object of type 'ExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpec(obj: ExternalSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ExternalSecretSpecData(y)),
    'dataFrom': obj.dataFrom?.map(y => toJson_ExternalSecretSpecDataFrom(y)),
    'refreshInterval': obj.refreshInterval,
    'secretStoreRef': toJson_ExternalSecretSpecSecretStoreRef(obj.secretStoreRef),
    'target': toJson_ExternalSecretSpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ExternalSecretSpecData
 */
export interface ExternalSecretSpecData {
  /**
   * ExternalSecretDataRemoteRef defines Provider data location.
   *
   * @schema ExternalSecretSpecData#remoteRef
   */
  readonly remoteRef: ExternalSecretSpecDataRemoteRef;

  /**
   * @schema ExternalSecretSpecData#secretKey
   */
  readonly secretKey: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecData(obj: ExternalSecretSpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_ExternalSecretSpecDataRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretDataRemoteRef defines Provider data location.
 *
 * @schema ExternalSecretSpecDataFrom
 */
export interface ExternalSecretSpecDataFrom {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretSpecDataFrom#conversionStrategy
   */
  readonly conversionStrategy?: string;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretSpecDataFrom#key
   */
  readonly key: string;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretSpecDataFrom#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretSpecDataFrom#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecDataFrom(obj: ExternalSecretSpecDataFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'key': obj.key,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretSpecSecretStoreRef
 */
export interface ExternalSecretSpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretSpecSecretStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretSpecSecretStoreRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecSecretStoreRef(obj: ExternalSecretSpecSecretStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
 *
 * @schema ExternalSecretSpecTarget
 */
export interface ExternalSecretSpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
   *
   * @default Owner'
   * @schema ExternalSecretSpecTarget#creationPolicy
   */
  readonly creationPolicy?: string;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ExternalSecretSpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ExternalSecretSpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ExternalSecretSpecTarget#template
   */
  readonly template?: ExternalSecretSpecTargetTemplate;

}

/**
 * Converts an object of type 'ExternalSecretSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTarget(obj: ExternalSecretSpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationPolicy': obj.creationPolicy,
    'immutable': obj.immutable,
    'name': obj.name,
    'template': toJson_ExternalSecretSpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretDataRemoteRef defines Provider data location.
 *
 * @schema ExternalSecretSpecDataRemoteRef
 */
export interface ExternalSecretSpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretSpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: string;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretSpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretSpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretSpecDataRemoteRef#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecDataRemoteRef(obj: ExternalSecretSpecDataRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'key': obj.key,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ExternalSecretSpecTargetTemplate
 */
export interface ExternalSecretSpecTargetTemplate {
  /**
   * @schema ExternalSecretSpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
   *
   * @schema ExternalSecretSpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ExternalSecretSpecTargetTemplate#metadata
   */
  readonly metadata?: ExternalSecretSpecTargetTemplateMetadata;

  /**
   * @schema ExternalSecretSpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ExternalSecretSpecTargetTemplateTemplateFrom[];

  /**
   * @schema ExternalSecretSpecTargetTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplate(obj: ExternalSecretSpecTargetTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'metadata': toJson_ExternalSecretSpecTargetTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_ExternalSecretSpecTargetTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ExternalSecretSpecTargetTemplateMetadata
 */
export interface ExternalSecretSpecTargetTemplateMetadata {
  /**
   * @schema ExternalSecretSpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ExternalSecretSpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateMetadata(obj: ExternalSecretSpecTargetTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFrom
 */
export interface ExternalSecretSpecTargetTemplateTemplateFrom {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ExternalSecretSpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ExternalSecretSpecTargetTemplateTemplateFromSecret;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFrom(obj: ExternalSecretSpecTargetTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj.configMap),
    'secret': toJson_ExternalSecretSpecTargetTemplateTemplateFromSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromConfigMap {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj: ExternalSecretSpecTargetTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromSecret {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ExternalSecretSpecTargetTemplateTemplateFromSecretItems[];

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromSecret(obj: ExternalSecretSpecTargetTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretSpecTargetTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(obj: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItems
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromSecretItems {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromSecretItems(obj: ExternalSecretSpecTargetTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecretV1Beta1
 */
export class ExternalSecretV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExternalSecretV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1beta1',
    kind: 'ExternalSecret',
  }

  /**
   * Renders a Kubernetes manifest for "ExternalSecretV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExternalSecretV1Beta1Props = {}): any {
    return {
      ...ExternalSecretV1Beta1.GVK,
      ...toJson_ExternalSecretV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ExternalSecretV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExternalSecretV1Beta1Props = {}) {
    super(scope, id, {
      ...ExternalSecretV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExternalSecretV1Beta1.GVK,
      ...toJson_ExternalSecretV1Beta1Props(resolved),
    };
  }
}

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecretV1Beta1
 */
export interface ExternalSecretV1Beta1Props {
  /**
   * @schema ExternalSecretV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExternalSecretSpec defines the desired state of ExternalSecret.
   *
   * @schema ExternalSecretV1Beta1#spec
   */
  readonly spec?: ExternalSecretV1Beta1Spec;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1Props(obj: ExternalSecretV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExternalSecretV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretSpec defines the desired state of ExternalSecret.
 *
 * @schema ExternalSecretV1Beta1Spec
 */
export interface ExternalSecretV1Beta1Spec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ExternalSecretV1Beta1Spec#data
   */
  readonly data?: ExternalSecretV1Beta1SpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ExternalSecretV1Beta1Spec#dataFrom
   */
  readonly dataFrom?: ExternalSecretV1Beta1SpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ExternalSecretV1Beta1Spec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1Spec#secretStoreRef
   */
  readonly secretStoreRef?: ExternalSecretV1Beta1SpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
   *
   * @schema ExternalSecretV1Beta1Spec#target
   */
  readonly target?: ExternalSecretV1Beta1SpecTarget;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1Spec(obj: ExternalSecretV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ExternalSecretV1Beta1SpecData(y)),
    'dataFrom': obj.dataFrom?.map(y => toJson_ExternalSecretV1Beta1SpecDataFrom(y)),
    'refreshInterval': obj.refreshInterval,
    'secretStoreRef': toJson_ExternalSecretV1Beta1SpecSecretStoreRef(obj.secretStoreRef),
    'target': toJson_ExternalSecretV1Beta1SpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ExternalSecretV1Beta1SpecData
 */
export interface ExternalSecretV1Beta1SpecData {
  /**
   * RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
   *
   * @schema ExternalSecretV1Beta1SpecData#remoteRef
   */
  readonly remoteRef: ExternalSecretV1Beta1SpecDataRemoteRef;

  /**
   * SecretKey defines the key in which the controller stores the value. This is the key in the Kind=Secret
   *
   * @schema ExternalSecretV1Beta1SpecData#secretKey
   */
  readonly secretKey: string;

  /**
   * SourceRef allows you to override the source from which the value will pulled from.
   *
   * @schema ExternalSecretV1Beta1SpecData#sourceRef
   */
  readonly sourceRef?: ExternalSecretV1Beta1SpecDataSourceRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecData(obj: ExternalSecretV1Beta1SpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_ExternalSecretV1Beta1SpecDataRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
    'sourceRef': toJson_ExternalSecretV1Beta1SpecDataSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecDataFrom
 */
export interface ExternalSecretV1Beta1SpecDataFrom {
  /**
   * Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#extract
   */
  readonly extract?: ExternalSecretV1Beta1SpecDataFromExtract;

  /**
   * Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#find
   */
  readonly find?: ExternalSecretV1Beta1SpecDataFromFind;

  /**
   * Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#rewrite
   */
  readonly rewrite?: ExternalSecretV1Beta1SpecDataFromRewrite[];

  /**
   * SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#sourceRef
   */
  readonly sourceRef?: ExternalSecretV1Beta1SpecDataFromSourceRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFrom(obj: ExternalSecretV1Beta1SpecDataFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': toJson_ExternalSecretV1Beta1SpecDataFromExtract(obj.extract),
    'find': toJson_ExternalSecretV1Beta1SpecDataFromFind(obj.find),
    'rewrite': obj.rewrite?.map(y => toJson_ExternalSecretV1Beta1SpecDataFromRewrite(y)),
    'sourceRef': toJson_ExternalSecretV1Beta1SpecDataFromSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecSecretStoreRef
 */
export interface ExternalSecretV1Beta1SpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecSecretStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecSecretStoreRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecSecretStoreRef(obj: ExternalSecretV1Beta1SpecSecretStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
 *
 * @schema ExternalSecretV1Beta1SpecTarget
 */
export interface ExternalSecretV1Beta1SpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
   *
   * @default Owner'
   * @schema ExternalSecretV1Beta1SpecTarget#creationPolicy
   */
  readonly creationPolicy?: ExternalSecretV1Beta1SpecTargetCreationPolicy;

  /**
   * DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'
   *
   * @default Retain'
   * @schema ExternalSecretV1Beta1SpecTarget#deletionPolicy
   */
  readonly deletionPolicy?: ExternalSecretV1Beta1SpecTargetDeletionPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ExternalSecretV1Beta1SpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ExternalSecretV1Beta1SpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ExternalSecretV1Beta1SpecTarget#template
   */
  readonly template?: ExternalSecretV1Beta1SpecTargetTemplate;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTarget(obj: ExternalSecretV1Beta1SpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationPolicy': obj.creationPolicy,
    'deletionPolicy': obj.deletionPolicy,
    'immutable': obj.immutable,
    'name': obj.name,
    'template': toJson_ExternalSecretV1Beta1SpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRef
 */
export interface ExternalSecretV1Beta1SpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: string;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#decodingStrategy
   */
  readonly decodingStrategy?: string;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#metadataPolicy
   */
  readonly metadataPolicy?: string;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataRemoteRef(obj: ExternalSecretV1Beta1SpecDataRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceRef allows you to override the source from which the value will pulled from.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRef {
  /**
   * GeneratorRef points to a generator custom resource in
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretV1Beta1SpecDataSourceRefStoreRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRef(obj: ExternalSecretV1Beta1SpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ExternalSecretV1Beta1SpecDataSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtract
 */
export interface ExternalSecretV1Beta1SpecDataFromExtract {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#conversionStrategy
   */
  readonly conversionStrategy?: string;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#decodingStrategy
   */
  readonly decodingStrategy?: string;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#metadataPolicy
   */
  readonly metadataPolicy?: string;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromExtract' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromExtract(obj: ExternalSecretV1Beta1SpecDataFromExtract | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFind
 */
export interface ExternalSecretV1Beta1SpecDataFromFind {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#conversionStrategy
   */
  readonly conversionStrategy?: string;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#decodingStrategy
   */
  readonly decodingStrategy?: string;

  /**
   * Finds secrets based on the name.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#name
   */
  readonly name?: ExternalSecretV1Beta1SpecDataFromFindName;

  /**
   * A root path to start the find operations.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#path
   */
  readonly path?: string;

  /**
   * Find secrets based on tags.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromFind' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromFind(obj: ExternalSecretV1Beta1SpecDataFromFind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'name': toJson_ExternalSecretV1Beta1SpecDataFromFindName(obj.name),
    'path': obj.path,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecDataFromRewrite
 */
export interface ExternalSecretV1Beta1SpecDataFromRewrite {
  /**
   * Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewrite#regexp
   */
  readonly regexp?: ExternalSecretV1Beta1SpecDataFromRewriteRegexp;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewrite(obj: ExternalSecretV1Beta1SpecDataFromRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': toJson_ExternalSecretV1Beta1SpecDataFromRewriteRegexp(obj.regexp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRef {
  /**
   * GeneratorRef points to a generator custom resource in
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRef(obj: ExternalSecretV1Beta1SpecDataFromSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
 *
 * @default Owner'
 * @schema ExternalSecretV1Beta1SpecTargetCreationPolicy
 */
export enum ExternalSecretV1Beta1SpecTargetCreationPolicy {
  /** Owner */
  OWNER = 'Owner',
  /** Orphan */
  ORPHAN = 'Orphan',
  /** Merge */
  MERGE = 'Merge',
  /** None */
  NONE = 'None',
}

/**
 * DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'
 *
 * @default Retain'
 * @schema ExternalSecretV1Beta1SpecTargetDeletionPolicy
 */
export enum ExternalSecretV1Beta1SpecTargetDeletionPolicy {
  /** Delete */
  DELETE = 'Delete',
  /** Merge */
  MERGE = 'Merge',
  /** Retain */
  RETAIN = 'Retain',
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplate
 */
export interface ExternalSecretV1Beta1SpecTargetTemplate {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#metadata
   */
  readonly metadata?: ExternalSecretV1Beta1SpecTargetTemplateMetadata;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplate(obj: ExternalSecretV1Beta1SpecTargetTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'metadata': toJson_ExternalSecretV1Beta1SpecTargetTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GeneratorRef points to a generator custom resource in
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the resource, e.g. Password, ACRAccessToken etc.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#kind
   */
  readonly kind: string;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(obj: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRefStoreRef(obj: ExternalSecretV1Beta1SpecDataSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Finds secrets based on the name.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindName
 */
export interface ExternalSecretV1Beta1SpecDataFromFindName {
  /**
   * Finds secrets base
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFindName#regexp
   */
  readonly regexp?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromFindName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromFindName(obj: ExternalSecretV1Beta1SpecDataFromFindName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': obj.regexp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp
 */
export interface ExternalSecretV1Beta1SpecDataFromRewriteRegexp {
  /**
   * Used to define the regular expression of a re.Compiler.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp#source
   */
  readonly source: string;

  /**
   * Used to define the target pattern of a ReplaceAll operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp#target
   */
  readonly target: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewriteRegexp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewriteRegexp(obj: ExternalSecretV1Beta1SpecDataFromRewriteRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GeneratorRef points to a generator custom resource in
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the resource, e.g. Password, ACRAccessToken etc.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#kind
   */
  readonly kind: string;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(obj: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(obj: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateMetadata {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateMetadata(obj: ExternalSecretV1Beta1SpecTargetTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(obj.configMap),
    'secret': toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

